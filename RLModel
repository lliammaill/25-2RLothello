import numpy as np
import gym
from gym import spaces

class OthelloEnv(gym.Env):
    def __init__(self):
        super().__init__()
        self.size = 8
        self.action_space = spaces.Discrete(self.size * self.size)
        self.observation_space = spaces.Box(low=0, high=2, shape=(self.size, self.size), dtype=int)
        self.reset()

    def reset(self):
        self.board = np.zeros((self.size, self.size), dtype=int)
        mid = self.size // 2
        self.board[mid-1][mid-1], self.board[mid][mid] = 2, 2
        self.board[mid-1][mid], self.board[mid][mid-1] = 1, 1
        self.current_player = 1
        return self.board.copy()

    def get_opponent(self):
        return 3 - self.current_player

    def is_on_board(self, x, y):
        return 0 <= x < self.size and 0 <= y < self.size

    def valid_moves(self):
        directions = [(-1,-1), (-1,0), (-1,1),
                      (0,-1),          (0,1),
                      (1,-1),  (1,0),  (1,1)]
        valid = set()
        opponent = self.get_opponent()
        for x in range(self.size):
            for y in range(self.size):
                if self.board[x,y] != 0:
                    continue
                for dx, dy in directions:
                    nx, ny = x + dx, y + dy
                    if self.is_on_board(nx, ny) and self.board[nx, ny] == opponent:
                        while self.is_on_board(nx, ny):
                            if self.board[nx, ny] == 0:
                                break
                            if self.board[nx, ny] == self.current_player:
                                valid.add(x*self.size + y)
                                break
                            nx += dx
                            ny += dy
        return valid

    def flip_discs(self, x, y):
        directions = [(-1,-1), (-1,0), (-1,1),
                      (0,-1),          (0,1),
                      (1,-1),  (1,0),  (1,1)]
        opponent = self.get_opponent()
        to_flip = []
        for dx, dy in directions:
            nx, ny = x + dx, y + dy
            temp = []
            while self.is_on_board(nx, ny) and self.board[nx, ny] == opponent:
                temp.append((nx, ny))
                nx += dx
                ny += dy
            if self.is_on_board(nx, ny) and self.board[nx, ny] == self.current_player:
                to_flip.extend(temp)
        for fx, fy in to_flip:
            self.board[fx, fy] = self.current_player
        return len(to_flip)

    def step(self, action):
        x, y = divmod(action, self.size)
        valid = self.valid_moves()
        if action not in valid:
            reward = -1
            done = False
            info = {"invalid_move": True}
            return self.board.copy(), reward, done, info
        self.board[x, y] = self.current_player
        flipped = self.flip_discs(x, y)
        reward = flipped

        # 플레이어 교대 후 유효 수 체크
        self.current_player = self.get_opponent()
        if not self.valid_moves():
            self.current_player = self.get_opponent()
            if not self.valid_moves():
                done = True
            else:
                done = False
        else:
            done = False
        info = {"flipped": flipped}
        return self.board.copy(), reward, done, info

    def render(self):
        print(self.board)

# 테스트 코드
if __name__ == "__main__":
    env = OthelloEnv()
    env.reset()
    env.render()
    print("Valid moves:", env.valid_moves())
    print("플레이어가 위치 19(2,3)에 착수")
    obs, reward, done, info = env.step(19)
    env.render()
    print(f"Reward: {reward}, Done: {done}, Info: {info}")
